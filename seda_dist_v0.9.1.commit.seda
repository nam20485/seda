#!/usr/bin/env python3
"""
Inaugural Release: SEDA v0.9.1 (Hotfix)

This commit establishes the official v0.9.1 release of the SEDA protocol
and toolset.

Summary of Changes:
1. Updated Versioning:
   - Set protocol version to v0.9.1 in `README.md`.
   - Updated `seda_packer.py` to stamp generated files with v0.9.1.

2. Documentation:
   - Included self-replication instructions in `README.md` and `AGENTS.md`.
   - Fixed syntax error in AGENTS.md payload caused by literal triple quotes.

This archive serves as the "Golden Master" for SEDA v0.9.1.
"""
import os
import base64
import sys
import re

# --- PAYLOAD SECTION ---
# Sentinel Strategy: |TRIPLE_QUOTE| is used to prevent syntax errors
# in this self-reproducing code.
PAYLOAD = {
    # ==========================================
    # 1. README.md
    # ==========================================
    "README.md": r'''# üì¶ SEDA: Self-Extracting Document Archive

**Version:** 0.9.1
**Status:** Beta

## What is SEDA?
SEDA is a protocol for packaging files, directory structures, and metadata into a single, executable Python script. It effectively turns a directory of code into a self-contained installer.

## Motivation
The protocol was invented to solve a specific friction point in AI-assisted software development: **The "Copy-Paste" Bottleneck.**

When an AI generates a multi-file project or a complex refactor:
1.  The human must copy/paste multiple files.
2.  File paths and directory structures are often lost or manual.
3.  The "context" (why these changes were made) is lost when moving from Chat to Git.

SEDA solves this by encapsulating the **Code**, the **Structure**, and the **Context** (Commit Message) into a single file that does the work for you.

## How It Works
A `.seda` file is a polyglot file format. This means that both of the following statements are true at the same time:

* It is a valid Python script (.py) containing:
    1. **The Header:** A docstring containing metadata or commit messages.
    2. **The Payload:** A Python dictionary where keys are file paths and values are content (Text or Base64-encoded Binary).
    3. **The Engine:** A small, embedded script that iterates through the payload and writes files to disk.

* It is also a valid Markdown file (.md) containing documentation or instructions for use.

> *But how can both of these be true at the same time fow one file?*, you say. I know- its a real mind-bender. But I can assure you, my mind-blown reader, it is quite true. Read on...

## The Tools

### `seda_packer.py`
Creates SEDA archives from existing directories.

**Usage:**
```bash
# Create a standard archive from a specific folder
python tools/seda_packer.py ./my-project

# Create a Commit Archive (Type 5) with a specific message
python tools/seda_packer.py ./my-project --docstring "Fix login bug" --output fix_login.commit.seda

# Create a self-distribution of the current repo (Type 0)
python tools/seda_packer.py . --output release_v0.9.1.seda

# Create a self-documenting distribution (Type 5) using README as the commit message
python tools/seda_packer.py . --docstring-file README.md --output release_v0.9.1.commit.seda
```

### `seda_bootstrap.py`
A lightweight script to generate SEDA files if the packer is not available.

## File Format & Subtypes

### üü¢ Type 0: SEDA-Core
The standard format.
* **Extension:** `.seda`
* **Behavior:** Unpacks files to the current directory.
* **Use Case:** Backups, project transport.

### üü† Type 5: SEDA-Commit
The "Patch" format.
* **Extension:** `.commit.seda`
* **Behavior:** 1.  Unpacks files to the current directory.
    2.  Extracts the archive's internal docstring/header into a file named `commit_msg.txt`.
* **Use Case:** Rapid "Chat-to-Git" workflow.
* **Workflow:**
    ```bash
    python feature.commit.seda
    git add .
    git commit -F commit_msg.txt
    ```
''',

    # ==========================================
    # 2. AGENTS.md
    # ==========================================
    # HOTFIX: Replaced literal triple quotes with sentinel to prevent syntax error
    "AGENTS.md": r'''# Instructions for AI Agents

If you are an LLM or AI Agent generating SEDA files, follow these guidelines to ensure reliability.

## 1. Syntax Safety (The Sentinel Strategy)
Because SEDA files use Python string literals (`r|TRIPLE_QUOTE|...|TRIPLE_QUOTE|`) to store content, you must ensure the content itself does not contain the delimiter.

**Rule:**
If a source file contains triple quotes (`|TRIPLE_QUOTE|`), you **must** replace them with a unique placeholder (e.g., `|TRIPLE_QUOTE|`) in the dictionary definition, and append `.replace("|TRIPLE_QUOTE|", "|TRIPLE_QUOTE|")` to that specific dictionary entry.

**Bad:**
```python
"script.py": r|TRIPLE_QUOTE|print(|TRIPLE_QUOTE|hello|TRIPLE_QUOTE|)|TRIPLE_QUOTE| # Syntax Error!
```

**Good:**
```python
"script.py": r|TRIPLE_QUOTE|print(|TRIPLE_QUOTE|hello|TRIPLE_QUOTE|)|TRIPLE_QUOTE|.replace("|TRIPLE_QUOTE|", "|TRIPLE_QUOTE|")
```

## 2. Choosing the Right Type
* **Default:** Use **Type 0** (`.seda`) for general file bundles.
* **Code Changes:** Use **Type 5** (`.commit.seda`) when you are proposing changes to a repository. Write your explanation (the "Commit Message") as the top-level docstring of the file.

## 3. Binary Handling
If you need to include binary assets (images, PDFs), encode them in **Base64**. The SEDA extractor logic automatically detects common binary extensions (`.png`, `.jpg`, etc.) and decodes them upon extraction.

## 4. Self-Replication
To create a distribution of the current environment (including the SEDA tools themselves), use:
```bash
python tools/seda_packer.py . --docstring-file README.md --output distribution.commit.seda
```
This creates a Type 5 archive that serves as a self-contained installer for the repository.
'''.replace("|TRIPLE_QUOTE|", "'''"),

    # ==========================================
    # 3. SEDA Packer Tool (v0.9.1)
    # ==========================================
    "tools/seda_packer.py": r'''import os
import sys
import argparse
import base64

# Configuration: Folders to always ignore (Defaults)
DEFAULT_IGNORE_DIRS = {
    'node_modules', '__pycache__', '.git', 'dist', 'build', 
    '.DS_Store', '.idea', '.vscode', 'coverage'
}

# Configuration: File extensions to always ignore (Defaults)
DEFAULT_IGNORE_EXTENSIONS = {
    '.pyc', '.log', '.seda', '.exe', '.dll', '.so', '.dylib'
}

# The template for the extractor logic
EXTRACTOR_TEMPLATE = r|TRIPLE_QUOTE|
import os
import sys
import base64
import re

def extract_payload():
    current_file = os.path.basename(__file__)
    print(f"üì¶ Unpacking SEDA Archive: {current_file}...")
    
    # --- FEATURE: SEDA-Commit Message Extraction (Type 5) ---
    if current_file.endswith('.commit.seda') or current_file.endswith('.commit.py'):
        try:
            with open(__file__, 'r', encoding='utf-8') as f:
                content = f.read()
                # Extract content between the first set of triple quotes
                match = re.search(r'"""(.*?)"""', content, re.DOTALL)
                if match:
                    msg = match.group(1).strip()
                    lines = [l for l in msg.splitlines() if not l.startswith("#!")]
                    clean_msg = "\n".join(lines).strip()
                    
                    with open("commit_msg.txt", "w", encoding="utf-8") as msg_file:
                        msg_file.write(clean_msg)
                    print("   üìù SEDA-Commit detected: extracted 'commit_msg.txt'")
        except Exception as e:
            print(f"   ‚ö†Ô∏è Could not extract commit message: {e}")
    # --------------------------------------------------------

    for filepath, content in project_files.items():
        dest_path = os.path.join(os.getcwd(), filepath)
        directory = os.path.dirname(dest_path)
        
        if directory:
            os.makedirs(directory, exist_ok=True)
        
        try:
            if isinstance(content, bytes):
                with open(dest_path, 'wb') as f:
                    f.write(content)
            else:
                if filepath.endswith(('.png', '.jpg', '.ico', '.svg', '.pdf')):
                     with open(dest_path, 'wb') as f:
                        f.write(base64.b64decode(content))
                else:
                    with open(dest_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                        
            print(f"   ‚úÖ Extracted: {filepath}")
        except Exception as e:
            print(f"   ‚ùå Error extracting {filepath}: {e}")

    print("\n‚ú® Extraction complete! ‚ú®")

if __name__ == "__main__":
    extract_payload()
|TRIPLE_QUOTE|

def is_binary(file_path):
    """Simple check to see if a file is binary text."""
    try:
        with open(file_path, 'tr') as check_file:
            check_file.read()
            return False
    except:
        return True

def generate_seda(source_dir, output_filename, recursive_pack_seda=False, extra_ignore_dirs=None, extra_ignore_exts=None, docstring=None):
    source_dir = os.path.abspath(source_dir)
    
    # Setup ignore sets
    ignore_dirs = set(DEFAULT_IGNORE_DIRS)
    if extra_ignore_dirs:
        ignore_dirs.update(extra_ignore_dirs)
        
    ignore_exts = set(DEFAULT_IGNORE_EXTENSIONS)
    if extra_ignore_exts:
        ignore_exts.update(extra_ignore_exts)
        
    # Handle recursion flag
    if recursive_pack_seda and '.seda' in ignore_exts:
        ignore_exts.remove('.seda')
    
    if not os.path.exists(source_dir):
        print(f"Error: Source directory '{source_dir}' does not exist.")
        return

    print(f"üóÑÔ∏è  Packing '{os.path.basename(source_dir)}' into '{output_filename}'...")
    print(f"   ‚ÑπÔ∏è  Recursive SEDA Packing: {'ENABLED' if recursive_pack_seda else 'DISABLED'}")
    
    if docstring:
        print("   üìù Attaching custom commit message/docstring.")

    file_data = {}

    for root, dirs, files in os.walk(source_dir):
        # Filter ignored directories
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
            
        for file in files:
            # Check extensions
            if any(file.endswith(ext) for ext in ignore_exts):
                continue
                
            full_path = os.path.join(root, file)
            rel_path = os.path.relpath(full_path, source_dir)
            rel_path = rel_path.replace('\\', '/')

            try:
                if is_binary(full_path):
                    with open(full_path, "rb") as f:
                        encoded = base64.b64encode(f.read()).decode('utf-8')
                        file_data[rel_path] = encoded
                else:
                    with open(full_path, "r", encoding="utf-8") as f:
                        file_data[rel_path] = f.read()
                    
                print(f"   ‚ûï Added: {rel_path}")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Skipping {rel_path}: {e}")

    with open(output_filename, "w", encoding="utf-8") as out:
        out.write("#!/usr/bin/env python3\n")
        
        # WRITE THE DOCSTRING / COMMIT MESSAGE
        if docstring:
            out.write('"""\n')
            out.write(docstring)
            out.write('\n"""\n')
        else:
            out.write('"""\n# SEDA Archive\n"""\n')
            
        out.write("# Generated by SEDA Packer v0.9.1\n\n")
        out.write("project_files = {\n")
        
        for path, content in file_data.items():
            # SENTINEL CHECK: Guard against delimiter collision
            if isinstance(content, str) and "|TRIPLE_QUOTE|" not in content:
                 out.write(f"    '{path}': r|TRIPLE_QUOTE|{content}|TRIPLE_QUOTE|,\n")
            else:
                 print(f"   üõ°Ô∏è  Sentinel Active: {path} contains delimiters. Using safe repr().")
                 out.write(f"    '{path}': {repr(content)},\n")
                 
        out.write("}\n")
        out.write(EXTRACTOR_TEMPLATE)
    
    # Make the generated archive executable
    try:
        os.chmod(output_filename, 0o755)
        print(f"   üîß Permissions set to executable (755)")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Could not set executable permissions: {e}")

    print(f"\nüéâ SEDA archive created: {output_filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="SEDA Packer Tool v0.9.1")
    parser.add_argument("source_dir", help="Directory to pack")
    parser.add_argument("output_filename", nargs="?", help="Output filename (default: <dirname>.seda)")
    
    # Flags
    parser.add_argument("--recursive-pack-seda", action="store_true", help="Allow packing of .seda files")
    parser.add_argument("--ignore-dirs", help="Comma-separated list of additional directories to ignore")
    parser.add_argument("--ignore-exts", help="Comma-separated list of additional extensions to ignore")
    
    # New Commit SEDA Flags
    parser.add_argument("--docstring", help="Text to use as the file docstring (commit message)")
    parser.add_argument("--docstring-file", help="File containing text to use as the docstring")

    args = parser.parse_args()
    
    # Process defaults
    target_dir = args.source_dir
    output_name = args.output_filename if args.output_filename else f"{os.path.basename(os.path.abspath(target_dir))}.seda"
    if not output_name.endswith('.seda') and not output_name.endswith('.py'):
        output_name += '.seda'
        
    # Process Lists
    extra_dirs = args.ignore_dirs.split(',') if args.ignore_dirs else []
    extra_exts = args.ignore_exts.split(',') if args.ignore_exts else []
    
    # Process Docstring
    doc_text = args.docstring
    if args.docstring_file:
        try:
            with open(args.docstring_file, 'r', encoding='utf-8') as f:
                doc_text = f.read()
        except Exception as e:
            print(f"Error reading docstring file: {e}")
            sys.exit(1)

    generate_seda(target_dir, output_name, args.recursive_pack_seda, extra_dirs, extra_exts, doc_text)
'''.replace("|TRIPLE_QUOTE|", "'''"),

    # ==========================================
    # 4. SEDA Bootstrap Tool (Legacy/Backup)
    # ==========================================
    "tools/seda_bootstrap.py": r'''import os
import sys
import base64

# The "Self-Exploding" Header
BOOTSTRAP_HEADER = r|TRIPLE_QUOTE|#!/usr/bin/env python3
"""
# üì¶ Self-Extracting Document Archive (SEDA)

This file is a **self-extracting archive**. You can read it as documentation, or you can **run it** to unpack the contents.

## üöÄ Quick Start

To extract the contents of this archive, simply run this file with Python:

```bash
python {filename}
```

## üìÑ Contents

This archive contains the following files:
{file_list}

---
**Technical Details:**
This file is a valid Python script that contains a payload of files encoded in Base64.
When executed, it will recreate the directory structure in your current folder.

_(The extraction logic is embedded below this documentation)_
"""
import os
import base64
import sys

# --- END OF DOCUMENTATION / START OF PAYLOAD ---
|TRIPLE_QUOTE|

# The Extractor Logic (The "Engine" inside the document)
EXTRACTOR_LOGIC = r|TRIPLE_QUOTE|
def extract_payload():
    print(f"üí• Self-Exploding SEDA Archive: {os.path.basename(__file__)}")
    print("   Extracting files...")
    
    for filepath, content in PAYLOAD.items():
        # Determine destination
        dest_path = os.path.join(os.getcwd(), filepath)
        directory = os.path.dirname(dest_path)
        
        # Create directories
        if directory:
            os.makedirs(directory, exist_ok=True)
        
        # Write file
        try:
            # If content is bytes (binary), write directly
            if isinstance(content, bytes):
                with open(dest_path, 'wb') as f:
                    f.write(content)
            # If content is string (text or base64 representation), handle accordingly
            elif isinstance(content, str):
                 # Heuristic: If it looks like a text file, try writing as text
                 # Otherwise try decoding base64
                 try:
                     # Try treating as base64 first for known binary extensions
                     if filepath.endswith(('.png', '.jpg', '.ico', '.svg', '.pdf', '.zip', '.exe')):
                         with open(dest_path, 'wb') as f:
                            f.write(base64.b64decode(content))
                     else:
                         # Default to text
                         with open(dest_path, 'w', encoding='utf-8') as f:
                            f.write(content)
                 except Exception:
                     # Fallback: write as raw text if decoding fails
                     with open(dest_path, 'w', encoding='utf-8') as f:
                        f.write(content)

            print(f"   ‚úÖ Extracted: {filepath}")
        except Exception as e:
            print(f"   ‚ùå Error extracting {filepath}: {e}")

    print("\n‚ú® Explosion complete! All files extracted. ‚ú®")

if __name__ == "__main__":
    extract_payload()
|TRIPLE_QUOTE|

IGNORE_DIRS = {
    'node_modules', '__pycache__', '.git', 'dist', 'build', 
    '.DS_Store', '.idea', '.vscode', 'coverage'
}

IGNORE_EXTENSIONS = {
    '.pyc', '.log', '.seda', '.exe', '.dll', '.so', '.dylib', '.zip'
}

def is_binary(file_path):
    """Check if file is binary."""
    try:
        with open(file_path, 'tr') as check_file:
            check_file.read()
            return False
    except:
        return True

def create_bootstrap_seda(source_dir, output_filename):
    source_dir = os.path.abspath(source_dir)
    
    if not os.path.exists(source_dir):
        print(f"Error: Source directory '{source_dir}' does not exist.")
        return

    print(f"üß® Preparing self-exploding document from '{os.path.basename(source_dir)}'...")

    file_data = {}
    file_list_md = ""

    for root, dirs, files in os.walk(source_dir):
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
        for file in files:
            if any(file.endswith(ext) for ext in IGNORE_EXTENSIONS):
                continue
            
            full_path = os.path.join(root, file)
            rel_path = os.path.relpath(full_path, source_dir).replace('\\', '/')
            
            file_list_md += f"- `{rel_path}`\n"

            try:
                if is_binary(full_path):
                    with open(full_path, "rb") as f:
                        encoded = base64.b64encode(f.read()).decode('utf-8')
                        file_data[rel_path] = encoded
                else:
                    with open(full_path, "r", encoding="utf-8") as f:
                        file_data[rel_path] = f.read()
                print(f"   ‚ûï Added: {rel_path}")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Skipping {rel_path}: {e}")

    # Assemble the document
    with open(output_filename, "w", encoding="utf-8") as out:
        # 1. Write the Header (Shebang + Markdown Doc)
        header = BOOTSTRAP_HEADER.format(
            filename=os.path.basename(output_filename),
            file_list=file_list_md
        )
        out.write(header)
        
        # 2. Write the Payload Dictionary
        out.write("\n# Payload Data\nPAYLOAD = {\n")
        for path, content in file_data.items():
            # Use repr() for safe string representation
            out.write(f"    '{path}': {repr(content)},\n")
        out.write("}\n")
        
        # 3. Write the Extractor Logic
        out.write(EXTRACTOR_LOGIC)

    # Make it executable (Unix/Linux/Mac)
    try:
        mode = os.stat(output_filename).st_mode
        os.chmod(output_filename, mode | 0o111)
    except:
        pass

    print(f"\nüéâ Self-Exploding Document created: {output_filename}")
    print(f"   Try running it: ./ {output_filename}  (or python {output_filename})")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python seda_bootstrap.py <directory_to_pack> [output_filename.py]")
    else:
        target_dir = sys.argv[1]
        output_name = sys.argv[2] if len(sys.argv) > 2 else f"{os.path.basename(os.path.abspath(target_dir))}_installer.py"
        create_bootstrap_seda(target_dir, output_name)
'''.replace("|TRIPLE_QUOTE|", "'''")
}

def extract_payload():
    current_file = os.path.basename(__file__)
    print(f"üì¶ Unpacking SEDA-Commit Archive: {current_file}...")
    
    # Type 5 Extraction Logic
    try:
        with open(__file__, 'r', encoding='utf-8') as f:
            content = f.read()
            match = re.search(r'"""(.*?)"""', content, re.DOTALL)
            if match:
                msg = match.group(1).strip()
                lines = [l for l in msg.splitlines() if not l.startswith("#!")]
                clean_msg = "\n".join(lines).strip()
                
                with open("commit_msg.txt", "w", encoding="utf-8") as msg_file:
                    msg_file.write(clean_msg)
                print("   üìù SEDA-Commit detected: extracted 'commit_msg.txt'")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Could not extract commit message: {e}")

    for filepath, content in PAYLOAD.items():
        dest_path = os.path.join(os.getcwd(), filepath)
        directory = os.path.dirname(dest_path)
        
        if directory:
            os.makedirs(directory, exist_ok=True)
        
        try:
            if isinstance(content, bytes):
                with open(dest_path, 'wb') as f:
                    f.write(content)
            elif isinstance(content, str):
                 try:
                     if filepath.endswith(('.png', '.jpg', '.ico', '.svg', '.pdf', '.zip', '.exe')):
                         with open(dest_path, 'wb') as f:
                            f.write(base64.b64decode(content))
                     else:
                         with open(dest_path, 'w', encoding='utf-8') as f:
                            f.write(content)
                 except Exception:
                     with open(dest_path, 'w', encoding='utf-8') as f:
                        f.write(content)

            print(f"   ‚úÖ Extracted: {filepath}")
        except Exception as e:
            print(f"   ‚ùå Error extracting {filepath}: {e}")

    print("\n‚ú® Explosion complete! SEDA Distribution unpacked. ‚ú®")

if __name__ == "__main__":
    extract_payload(),