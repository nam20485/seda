import os
import sys

# Configuration: Folders to always ignore
IGNORE_DIRS = {
    'node_modules', '__pycache__', '.git', 'dist', 'build', 
    '.DS_Store', '.idea', '.vscode', 'coverage'
}

# Configuration: File extensions to ignore
IGNORE_EXTENSIONS = {
    '.pyc', '.log', '.seda', '.exe', '.dll', '.so', '.dylib'
}

# The template for the extractor logic (the "engine" of the SEDA file)
EXTRACTOR_TEMPLATE = r'''
import os
import sys
import base64

def create_project():
    print(f"üì¶ Unpacking SEDA Archive: {os.path.basename(__file__)}...")
    
    for filepath, content in project_files.items():
        # Determine destination
        dest_path = os.path.join(os.getcwd(), filepath)
        directory = os.path.dirname(dest_path)
        
        # Create directories
        if directory:
            os.makedirs(directory, exist_ok=True)
        
        # Write file
        try:
            # Check if it is binary (base64 encoded) or text
            if isinstance(content, bytes):
                with open(dest_path, 'wb') as f:
                    f.write(content)
            else:
                # If it looks like base64 but is a string, decode it (binary fallback)
                if filepath.endswith(('.png', '.jpg', '.ico', '.svg', '.pdf')):
                     with open(dest_path, 'wb') as f:
                        f.write(base64.b64decode(content))
                else:
                    with open(dest_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                        
            print(f"   ‚úÖ Extracted: {filepath}")
        except Exception as e:
            print(f"   ‚ùå Error extracting {filepath}: {e}")

    print("\n‚ú® Extraction complete! ‚ú®")

if __name__ == "__main__":
    create_project()
'''

def is_binary(file_path):
"""Simple check to see if a file is binary text."""
try:
with open(file_path, 'tr') as check_file:
check_file.read()
return False
except:
return True

def generate_seda(source_dir, output_filename):
source_dir = os.path.abspath(source_dir)
    
if not os.path.exists(source_dir):
print(f"Error: Source directory '{source_dir}' does not exist.")
return

print(f"üóÑÔ∏è  Packing '{os.path.basename(source_dir)}' into '{output_filename}'...")

file_data = {}

for root, dirs, files in os.walk(source_dir):
# Filter ignored directories
dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
for file in files:
if any(file.endswith(ext) for ext in IGNORE_EXTENSIONS):
continue
            
full_path = os.path.join(root, file)
rel_path = os.path.relpath(full_path, source_dir)
            
# Windows compatibility for paths
rel_path = rel_path.replace('\\', '/')

try:
if is_binary(full_path):
# Read binary files as base64 strings to keep the .seda file text-based
import base64
with open(full_path, "rb") as f:
encoded = base64.b64encode(f.read()).decode('utf-8')
file_data[rel_path] = encoded
else:
# Read text files normally
with open(full_path, "r", encoding="utf-8") as f:
file_data[rel_path] = f.read()
                
print(f"   ‚ûï Added: {rel_path}")
except Exception as e:
print(f"   ‚ö†Ô∏è Skipping {rel_path}: {e}")

# Generate the actual SEDA script content
with open(output_filename, "w", encoding="utf-8") as out:
out.write("#!/usr/bin/env python3\n")
out.write("# SEDA: Self-Extracting Document Archive\n")
out.write("# Generated by SEDA Packer\n\n")
        
# Write the dictionary of files
# We use repr() to automatically handle escaping of quotes, backslashes, and newlines
out.write("project_files = {\n")
for path, content in file_data.items():
out.write(f"    '{path}': {repr(content)},\n")
out.write("}\n")
        
# Append the extraction logic
out.write(EXTRACTOR_TEMPLATE)

print(f"\nüéâ SEDA archive created: {output_filename}")
print(f"   Usage: python {output_filename}")

if __name__ == "__main__":
if len(sys.argv) < 2:
print("Usage: python seda_packer.py <directory_to_pack> [output_filename.seda]")
else:
target_dir = sys.argv[1]
output_name = sys.argv[2] if len(sys.argv) > 2 else f"{os.path.basename(os.path.abspath(target_dir))}.seda"
if not output_name.endswith('.seda') and not output_name.endswith('.py'):
output_name += '.seda'
             
generate_seda(target_dir, output_name)